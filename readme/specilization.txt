TEMPLATE SPECIALIZATION (C++)

------------------------------------------------------------
1. FULL SPECIALIZATION
------------------------------------------------------------
When you want a template to behave *differently for one exact type*.

TEMPLATE SPECIALIZATION (C++)

------------------------------------------------------------
1. FULL SPECIALIZATION
------------------------------------------------------------
When you want a template to behave *differently for one exact type*.

template <typename T>
class Printer {
public:
    void print(T value) {
        std::cout << value << "\n";
    }
};

// Full specialization for const char*
template <>
class Printer<const char*> {
public:
    void print(const char* value) {
        std::cout << "\"" << value << "\"\n"; // print with quotes
    }
};

// Usage
Printer<int>    p1;  p1.print(42);        // generic version
Printer<double> p2;  p2.print(3.14);      // generic version
Printer<const char*> p3; p3.print("hi");  // specialized version


------------------------------------------------------------
2. FUNCTION SPECIALIZATION
------------------------------------------------------------
Functions can also be specialized.

template <typename T>
T max_value(T a, T b) {
    return (a > b) ? a : b;
}

// Specialization for const char*
template <>
const char* max_value(const char* a, const char* b) {
    return std::strcmp(a, b) > 0 ? a : b;
}

// Usage
std::cout << max_value(3, 7);              // generic
std::cout << max_value("hi", "bye");       // specialized


------------------------------------------------------------
3. PARTIAL SPECIALIZATION (CLASSES ONLY)
------------------------------------------------------------
You cannot partially specialize function templates (only classes).
This allows customizing for a *family of types*.

Example: specialization for pointers

template <typename T>
class Box {
    T value;
public:
    Box(T v) : value(v) {}
    T get() const { return value; }
};

// Partial specialization for pointer types
template <typename T>
class Box<T*> {
    T* ptr;
public:
    Box(T* p) : ptr(p) {}
    T& get() const { return *ptr; }
};

// Usage
Box<int> b1(42);       // stores an int
Box<int*> b2(new int(7)); // stores pointer, dereferences on get()


------------------------------------------------------------
4. DEFAULTS + PARTIAL SPECIALIZATION
------------------------------------------------------------
You can combine default template arguments with specializations.

template <typename T, typename U = int>
class Pair {
    T first;
    U second;
public:
    Pair(T f, U s) : first(f), second(s) {}
};

// Partial specialization when both types are the same
template <typename T>
class Pair<T, T> {
    T values[2];
public:
    Pair(T a, T b) { values[0] = a; values[1] = b; }
};

// Usage
Pair<int, double> p1(3, 3.14);  // generic version
Pair<int, int>    p2(1, 2);     // partial specialization



------------------------------------------------------------
2. FUNCTION SPECIALIZATION
------------------------------------------------------------
Functions can also be specialized.

template <typename T>
T max_value(T a, T b) {
    return (a > b) ? a : b;
}

// Specialization for const char*
template <>
const char* max_value(const char* a, const char* b) {
    return std::strcmp(a, b) > 0 ? a : b;
}

// Usage
std::cout << max_value(3, 7);              // generic
std::cout << max_value("hi", "bye");       // specialized


------------------------------------------------------------
3. PARTIAL SPECIALIZATION (CLASSES ONLY)
------------------------------------------------------------
You cannot partially specialize function templates (only classes).
This allows customizing for a *family of types*.

Example: specialization for pointers

template <typename T>
class Box {
    T value;
public:
    Box(T v) : value(v) {}
    T get() const { return value; }
};

// Partial specialization for pointer types
template <typename T>TEMPLATE SPECIALIZATION (C++)

------------------------------------------------------------
1. FULL SPECIALIZATION
------------------------------------------------------------
When you want a template to behave *differently for one exact type*.

template <typename T>
class Printer {
public:
    void print(T value) {
        std::cout << value << "\n";
    }
};

// Full specialization for const char*
template <>
class Printer<const char*> {
public:
    void print(const char* value) {
        std::cout << "\"" << value << "\"\n"; // print with quotes
    }
};

// Usage
Printer<int>    p1;  p1.print(42);        // generic version
Printer<double> p2;  p2.print(3.14);      // generic version
Printer<const char*> p3; p3.print("hi");  // specialized version


------------------------------------------------------------
2. FUNCTION SPECIALIZATION
------------------------------------------------------------
Functions can also be specialized.

template <typename T>
T max_value(T a, T b) {
    return (a > b) ? a : b;
}

// Specialization for const char*
template <>
const char* max_value(const char* a, const char* b) {
    return std::strcmp(a, b) > 0 ? a : b;
}

// Usage
std::cout << max_value(3, 7);              // generic
std::cout << max_value("hi", "bye");       // specialized


------------------------------------------------------------
3. PARTIAL SPECIALIZATION (CLASSES ONLY)
------------------------------------------------------------
You cannot partially specialize function templates (only classes).
This allows customizing for a *family of types*.

Example: specialization for pointers

template <typename T>
class Box {
    T value;
public:
    Box(T v) : value(v) {}
    T get() const { return value; }
};

// Partial specialization for pointer types
template <typename T>
class Box<T*> {
    T* ptr;
public:
    Box(T* p) : ptr(p) {}
    T& get() const { return *ptr; }
};TEMPLATE SPECIALIZATION (C++)

------------------------------------------------------------
1. FULL SPECIALIZATION
------------------------------------------------------------
When you want a template to behave *differently for one exact type*.

template <typename T>
class Printer {
public:
    void print(T value) {
        std::cout << value << "\n";
    }
};

// Full specialization for const char*
template <>
class Printer<const char*> {
public:
    void print(const char* value) {
        std::cout << "\"" << value << "\"\n"; // print with quotes
    }
};

// Usage
Printer<int>    p1;  p1.print(42);        // generic version
Printer<double> p2;  p2.print(3.14);      // generic version
Printer<const char*> p3; p3.print("hi");  // specialized version


------------------------------------------------------------
2. FUNCTION SPECIALIZATION
------------------------------------------------------------
Functions can also be specialized.

template <typename T>
T max_value(T a, T b) {
    return (a > b) ? a : b;
}

// Specialization for const char*
template <>
const char* max_value(const char* a, const char* b) {
    return std::strcmp(a, b) > 0 ? a : b;
}

// Usage
std::cout << max_value(3, 7);              // generic
std::cout << max_value("hi", "bye");       // specialized


------------------------------------------------------------
3. PARTIAL SPECIALIZATION (CLASSES ONLY)
------------------------------------------------------------
You cannot partially specialize function templates (only classes).
This allows customizing for a *family of types*.

Example: specialization for pointers

template <typename T>
class Box {
    T value;
public:
    Box(T v) : value(v) {}
    T get() const { return value; }
};

// Partial specialization for pointer types
template <typename T>
class Box<T*> {
    T* ptr;
public:
    Box(T* p) : ptr(p) {}
    T& get() const { return *ptr; }
};

// Usage
Box<int> b1(42);       // stores an int
Box<int*> b2(new int(7)); // stores pointer, dereferences on get()


------------------------------------------------------------
4. DEFAULTS + PARTIAL SPECIALIZATION
------------------------------------------------------------
You can combine default template arguments with specializations.

template <typename T, typename U = int>
class Pair {
    T first;
    U second;
public:
    Pair(T f, U s) : first(f), second(s) {}
};

// Partial specialization when both types are the same
template <typename T>
class Pair<T, T> {
    T values[2];
public:
    Pair(T a, T b) { values[0] = a; values[1] = b; }
};

// Usage
Pair<int, double> p1(3, 3.14);  // generic version
Pair<int, int>    p2(1, 2);     // partial specialization


// Usage
Box<int> b1(42);       // stores an int
Box<int*> b2(new int(7)); // stores pointer, dereferences on get()


------------------------------------------------------------
4. DEFAULTS + PARTIAL SPECIALIZATION
------------------------------------------------------------
You can combine default template arguments with specializations.

template <typename T, typename U = int>
class Pair {
    T first;
    U second;
public:
    Pair(T f, U s) : first(f), second(s) {}
};

// Partial specialization when both types are the same
template <typename T>
class Pair<T, T> {
    T values[2];
public:
    Pair(T a, T b) { values[0] = a; values[1] = b; }
};

// Usage
Pair<int, double> p1(3, 3.14);  // generic version
Pair<int, int>    p2(1, 2);     // partial specialization

class Box<T*> {
    T* ptr;
public:
    Box(T* p) : ptr(p) {}
    T& get() const { return *ptr; }
};

// Usage
Box<int> b1(42);       // stores an int
Box<int*> b2(new int(7)); // stores pointer, dereferences on get()


------------------------------------------------------------
4. DEFAULTS + PARTIAL SPECIALIZATION
------------------------------------------------------------
You can combine default template arguments with specializations.

template <typename T, typename U = int>
class Pair {
    T first;
    U second;
public:
    Pair(T f, U s) : first(f), second(s) {}
};

// Partial specialization when both types are the same
template <typename T>
class Pair<T, T> {
    T values[2];
public:
    Pair(T a, T b) { values[0] = a; values[1] = b; }
};

// Usage
Pair<int, double> p1(3, 3.14);  // generic version
Pair<int, int>    p2(1, 2);     // partial specialization
